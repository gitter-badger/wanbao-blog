###JavaScript(摘要)

1. 内部函数
JavaScript 允许在一个函数内部定义函数，这一点我们在之前的 makePerson() 例子中也见过。关于 JavaScript 中的嵌套函数，一个很重要的细节是它们可以访问父函数作用域中的变量：

		function betterExampleNeeded() {
    		var a = 1;
	    	function oneMoreThanA() {
        		return a + 1;
    		}
    		return oneMoreThanA();
		}
		
 	如果某个函数依赖于其他的一两个函数，而这一两个函数对你其余的代码没有用处，你可以将它们嵌套在会被调用的那个函数内部	，这样做可以减少全局作用域下的函数的数量，这有利于编写易于维护的代码。

	这也是一个减少使用全局变量的好方法。当编写复杂代码时，程序员往往试图使用全局变量，将值共享给多个函数，但这样做会使代	码很难维护。内部函数可以共享父函数的变量，所以你可以使用这个特性把一些函数捆绑在一起，这样可以有效地防止“污染”你的全	局命名空间——你可以称它为“局部全局（local global）”。虽然这种方法应该谨慎使用，但它确实很有用，应该掌握。
	
2. 闭包
	下面我们将看到的是 JavaScript 中必须提到的功能最强大的抽象概念之一：闭包。但它可能也会带来一些潜在的困惑。那它究竟是做什么的呢？

		function makeAdder(a) {
    		return function(b) {
        		return a + b;
    		}
		}
		x = makeAdder(5);
		y = makeAdder(20);
		x(6); // ?
		y(7); // ?
makeAdder 这个名字本身应该能说明函数是用来做什么的：它创建了一个新的 adder 函数，这个函数自身带有一个参数，它被调用的时候这个参数会被加在外层函数传进来的参数上。

	这里发生的事情和前面介绍过的内嵌函数十分相似：一个函数被定义在了另外一个函数的内部，内部函数可以访问外部函数的变量。唯一的不同是，外部函数被返回了，那么常识告诉我们局部变量“应该”不再存在。但是它们却仍然存在——否则 adder 函数将不能工作。也就是说，这里存在 makeAdder 的局部变量的两个不同的“副本”——一个是 a 等于5，另一个是 a 等于20。那些函数的运行结果就如下所示：

	x(6); // 返回 11
	y(7); // 返回 27
	
	下面来说说到底发生了什么。每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（global object）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。

	所以当调用 makeAdder 时，解释器创建了一个作用域对象，它带有一个属性：a，这个属性被当作参数传入 makeAdder 函数。然后 makeAdder 返回一个新创建的函数。通常 JavaScript 的垃圾回收器会在这时回收 makeAdder 创建的作用域对象，但是返回的函数却保留一个指向那个作用域对象的引用。结果是这个作用域对象不会被垃圾回收器回收，直到指向 makeAdder 返回的那个函数对象的引用计数为零。

	作用域对象组成了一个名为作用域链（scope chain）的链。它类似于原形（prototype）链一样，被 JavaScript 的对象系统使用。

	一个闭包就是一个函数和被创建的函数中的作用域对象的组合。

	闭包允许你保存状态——所以它们通常可以代替对象来使用。这里有一些关于闭包的详细介绍。

3. 内存泄露

	使用闭包的一个坏处是，在 IE 浏览器中它会很容易导致内存泄露。JavaScript 是一种具有垃圾回收机制的语言——对象在被创建的时候分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存。宿主环境提供的对象都是按照这种方法被处理的。

	浏览器主机需要处理大量的对象来描绘一个正在被展现的 HTML 页面——DOM 对象。浏览器负责管理它们的内存分配和回收。

	IE 浏览器有自己的一套垃圾回收机制，这套机制与 JavaScript 提供的垃圾回收机制进行交互时，可能会发生内存泄露。

	在 IE 中，每当在一个 JavaScript 对象和一个本地对象之间形成循环引用时，就会发生内存泄露。如下所示：

		function leakMemory() {
    		var el = document.getElementById('el');
    		var o = { 'el': el };
    		el.o = o;
		}
		
	这段代码的循环引用会导致内存泄露：IE 不会释放被 el 和 o 使用的内存，直到浏览器被彻底关闭并重启后。

	这个例子往往无法引起人们的重视：一般只会在长时间运行的应用程序中，或者因为巨大的数据量和循环中导致内存泄露发生时，内存泄露才会引起注意。

	不过一般也很少发生如此明显的内存泄露现象——通常泄露的数据结构有多层的引用(references)，往往掩盖了循环引用的情况。

	闭包很容易发生无意识的内存泄露。如下所示：

		function addHandler() {
    		var el = document.getElementById('el');
    		el.onclick = function() {
        	el.style.backgroundColor = 'red';
    		}
		}
这段代码创建了一个元素，当它被点击的时候变红，但同时它也会发生内存泄露。为什么？因为对 el 的引用不小心被放在一个匿名内部函数中。这就在 JavaScript 对象（这个内部函数）和本地对象之间（el）创建了一个循环引用。

	这个问题有很多种解决方法，最简单的一种是不要使用 el 变量：

		function addHandler(){
    		document.getElementById('el').onclick = function(){
        		this.style.backgroundColor = 'red';
    		};
		}
	
	有趣的是，有一种窍门解决因闭包而引入的循环引用，是添加另外一个闭包：

		function addHandler() {
    		var clickHandler = function() {
        		this.style.backgroundColor = 'red';
    		};
    		(function() {
        	var el = document.getElementById('el');
        	el.onclick = clickHandler;
    		})();
		}
	内部函数被直接执行，并在 clickHandler 创建的闭包中隐藏了它的内容。

	另外一种避免闭包的好方法是在 window.onunload 事件发生期间破坏循环引用。很多事件库都能完成这项工作。注意这样做将使 Firefox 中的 bfcache 无法工作。所以除非有其他必要的原因，最好不要在 Firefox 中注册一个unload 的监听器。